#zero page usage

0000--0007 interrupt handler
0010--0017 indexed memory locations
0020--0037 function parameters
0040--0057 runtime function pointers
0060--0077 argument lvalues
      0077 return value as rvalue
0100--0177 activation record

#calling convention

Arguments are stored from left to right at 0020.
The return value is found in AC.
The return address is stored in the first word of
the procedure as JMS does.

#frame management

ECF (JMS I 0040)  establish call frame
(argc << 6 | framesize)
(lvalues: framesize words)
(argv: argc words)

copy framesize words from lvalues to 0100
copy argc words from 0020 to argv
write argc pointers to argv to 0060
clear AC
continue after argv

RCF (JMS I 0041)  restore call frame
(frame)

frame points to just after an EAR
same action as EAR but with an indirect activation record
except we don't copy arguments from 0020
clear AC
continue after frame

IAV (JMS I 0042)  initialize automatic variables
(pointer)
(len)
(data: len words)

copy len words from data to pointer
clear AC
continue after data

JSR (JMS I 0043)  jump subroutine, save, and restore
(len << 6 | offset)
(buf)
(fun)

copy len words from 0100 + offset to buf
then JMS I fun
then copy len words from buf to 0100 + offset
clear AC
continue after fun

#arithmetic

SHL (JMS I 0050)  shift left
(addr)

AC = *addr << AC
continue after addr


SHR (JMS I 0051)  shift right
(addr)

AC = *addr1 >> AC
continue after addr


MUL (JMS I 0052)  multiply (unsigned)
(addr)

AC = *addr * AC
continue after addr


DIV (JMS I 0053)  divide (unsigned)
(addr)

AC = *addr / AC
continue after addr


MOD (JMS I 0054)  modulo (unsigned)
(addr)

AC = *addr % AC
continue after addr


IOR (JMS I 0055)  inclusive or
(addr)

AC = *addr | AC
continue after addr


XOR (JMS I 0056)  exclusive or
(addr)

AC = *addr ^ AC
continue after addr
